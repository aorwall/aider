method: on_llm_end [2023-09-04 17:02:57]
llm_output: null
prompt:
from typing import Dict, List, Set, Tuple

class Board:
    def __init__(self, board: List[List[str]]):
        self._board = board
        
    def _get_neighbours(self, x: int, y: int) -> List[Tuple[int, int]]:
        directions = [(0, -1), (-1, 0), (1, 0), (0, 1)]
        neighbours = [(x + dx, y + dy) for dx, dy in directions]
        return neighbours
    
    def _valid_coordinates(self, x: int, y: int) -> bool:
        rows = len(self._board)
        cols = len(self._board[0])
        return 0 <= x < rows and 0 <= y < cols
    
    def territory(self, x: int, y: int) -> Tuple[str, Set[Tuple[int, int]]]:
        if not self._valid_coordinates(x, y):
            raise ValueError("Invalid coordinate")
            
        owner = self._board[x][y]
        visited = {(x, y)}
        stack = [(x, y)]
        
        while stack:
            current_x, current_y = stack.pop()
            for nx, ny in self._get_neighbours(current_x, current_y):
                if (nx, ny) not in visited and self._valid_coordinates(nx, ny) and \
                   ((owner == 'W' and self._board[nx][ny] != 'B') or 
                    (owner == 'B' and self._board[nx][ny] != 'W')) and \
                    self._board[nx][ny] != '.':
                    visited.add((nx, ny))
                    stack.append((nx, ny))
        return owner, visited
    
    def territories(self) -> Dict[str, Set[Tuple[int, int]]]:
        result = {'W': set(), 'B': set()}
        visited = set()
        
        for r in range(len(self._board)):
            for c in range(len(self._board[r])):
                if (r, c) not in visited and self._board[r][c] in ('W', 'B'):
                    owner, territory = self.territory(r, c)
                    result[owner] = result[owner].union(territory)
                    visited = visited.union(territory)
        return result

---
