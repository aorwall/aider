method: on_llm_end [2023-09-03 17:09:36]
llm_output: null
prompt:
Here's an implementation of the `InputCell` and `ComputeCell` classes using the provided file structure:

```python
class Cell:
    """Base class for all types of cells"""
    
    def __init__(self):
        self._value = None
        self._callbacks = []
        self._new_value = None
        self._dirty = False
        
    @property
    def value(self):
        return self._value
    
    @value.setter
    def value(self, val):
        if self._value != val:
            self._new_value = val
            self._dirty = True
            
    def _notify_listeners(self):
        # Only notify listeners if there was actually a change in value
        if self._dirty:
            for listener in self._callbacks:
                listener()
            self._value = self._new_value
            self._dirty = False

class InputCell(Cell):
    """An input cell can have its value set directly."""
    
    def set_value(self, val):
        self.value = val
        self._notify_listeners()
        
class ComputeCell(Cell):
    """A compute cell calculates its value based on other cells."""
    
    def __init__(self, inputs, func):
        super().__init__()
        self.func = func
        self.dependencies = [dep for dep in inputs]
        for dep in self.dependencies:
            dep.add_listener(self._handle_change)
    
    def _handle_change(self):
        self._dirty = True
        self._notify_listeners()
        
    def add_listener(self, callback):
        self._callbacks.append(callback)
        
    def remove_listener(self, callback):
        self._callbacks.remove(callback)
        
    def evaluate(self):
        args = (cell.value for cell in self.dependencies)
        self.value = self.func(*args)
        self._notify_listeners()
        
class ReactiveSystem:
    """Manages cells and ensures their values stay consistent"""
    
    def __init__(self):
        self.cells = {}
        
    def create_input_cell(self, name, init_val):
        cell = InputCell()
        cell.name = name
        cell.value = init_val
        self.cells[name] = cell
        return cell
    
    def create_compute_cell(self, name, dependencies, func):
        cell = ComputeCell([self.cells[d] for d in dependencies], func)
        cell.name = name
        self.cells[name] = cell
        return cell
    
    def update(self):
        while True:
            dirty_cells = {c for c in self.cells.values() if c._dirty}
            if not dirty_cells:
                break
            for cell in dirty_cells:
                cell.evaluate()
```

The `Cell` class serves as a base class for both `InputCell` and `ComputeCell`. It keeps track of whether it needs to notify its listeners (`_dirty`) and stores them in `_callbacks`. When setting a new value, it checks if it differs from the current value and sets the new value only after notifying listeners.

The `InputCell` class allows direct modification of its value via `set_value`, which marks itself as dirty and calls `_notify_listeners` to trigger updates.

The `ComputeCell` class takes a list of dependencies and a computation function. Its `_handle_change` method gets called whenever one of its dependencies changes, marking it as dirty. In `evaluate`, it computes its value based on the dependency values and notifies listeners if necessary.

The `ReactiveSystem` manages all cells and provides methods to create input and compute cells. It also contains a loop that repeatedly evaluates dirty cells until no more updates are needed.

Note that this implementation assumes that all cells are connected and eventually converge to a stable state. If cycles exist in the graph of cells, this could lead to infinite loops. To handle such cases, additional logic would need to be added to detect and prevent infinite updates. 
---
