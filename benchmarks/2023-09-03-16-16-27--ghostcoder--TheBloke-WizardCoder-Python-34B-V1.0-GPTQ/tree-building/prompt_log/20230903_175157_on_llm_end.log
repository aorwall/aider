method: on_llm_end [2023-09-03 17:51:57]
llm_output: null
prompt:
Here's the corrected implementation of `BuildTree` function that should pass all the given test cases:

```python
class Record:
    def __init__(self, record_id, parent_id):
        self.record_id = record_id
        self.parent_id = parent_id

class Node:
    def __init__(self, node_id):
        self.node_id = node_id
        self.children = []

def BuildTree(records):
    # Create a dictionary to store nodes by their id
    nodes = {}
    for rec in records:
        nodes[rec.record_id] = Node(rec.record_id)

    # Find the root node (the one with parent_id = 0)
    try:
        root = nodes[0]
    except KeyError:
        raise ValueError("Invalid input")

    # Iterate through each record and add children to their respective parents
    for rec in records:
        if rec.record_id == 0:
            continue
        
        try:
            nodes[rec.parent_id].children.append(nodes[rec.record_id])
        except KeyError:
            raise ValueError("Broken tree")

    return root
```

Explanation:
1. We initialize an empty dictionary called `nodes`. This will be used to store Nodes corresponding to each record_id.
2. We iterate over each record in `records`, create a new Node object using its `record_id` and add it to the `nodes` dictionary with key as `record_id` and value as the created Node object.
3. We then find the root node by accessing the Node object with key 0 from the `nodes` dictionary.
4. For every other record, we check if the `parent_id` is present in the `nodes` dictionary. If yes, we append the child node to its parent's list of children. Otherwise, we raise a `KeyError` since the tree is broken.
5. Finally, we return the root node.
6. In case there is no record with `record_id=0`, we raise a `ValueError` because the input is invalid.
7. Also, we skip adding the first record (with `record_id=0`) to the `nodes` dictionary since it represents the root node which has no parent. 
---
