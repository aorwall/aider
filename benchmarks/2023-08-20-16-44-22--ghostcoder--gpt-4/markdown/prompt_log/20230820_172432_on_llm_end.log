method: on_llm_end [2023-08-20 17:24:32]
llm_output: {"token_usage": {"prompt_tokens": 1152, "completion_tokens": 750, "total_tokens": 1902}, "model_name": "gpt-4"}
prompt:
The existing code is hard to read and maintain due to the following reasons:

1. The code is not modular. It's a single function doing multiple things.
2. There are repeated code blocks which can be abstracted into separate functions.
3. The code is not self-explanatory. It's hard to understand what each block of code is doing.
4. The code is not following the DRY (Don't Repeat Yourself) principle.

Here is the refactored code:

Filepath: markdown.py
```python
import re

def parse(markdown):
    lines = markdown.split('\n')
    res = ''
    in_list = False
    in_list_append = False
    for i in lines:
        header = parse_header(i)
        if header:
            i = header
        else:
            i, in_list, in_list_append = parse_list_item(i, in_list, in_list_append)
            i = parse_paragraph(i)
            i = parse_bold(i)
            i = parse_italic(i)
        if in_list_append:
            i = '</ul>' + i
            in_list_append = False
        res += i
    if in_list:
        res += '</ul>'
    return res

def parse_header(line):
    match = re.match("(#{1,6}) (.*)", line)
    if match:
        num = len(match.group(1))
        return f"<h{num}>{match.group(2)}</h{num}>"
    return None

def parse_list_item(line, in_list, in_list_append):
    match = re.match(r'\* (.*)', line)
    if match:
        curr = match.group(1)
        curr = parse_bold(curr)
        curr = parse_italic(curr)
        if not in_list:
            in_list = True
            return f'<ul><li>{curr}</li>', in_list, False
        else:
            return f'<li>{curr}</li>', in_list, False
    else:
        if in_list:
            in_list_append = True
            in_list = False
        return line, in_list, in_list_append

def parse_paragraph(line):
    if not re.match('<h|<ul|<p|<li', line):
        return f'<p>{line}</p>'
    return line

def parse_bold(line):
    match = re.match('(.*)__(.*)__(.*)', line)
    if match:
        return f"{match.group(1)}<strong>{match.group(2)}</strong>{match.group(3)}"
    return line

def parse_italic(line):
    match = re.match('(.*)_(.*)_(.*)', line)
    if match:
        return f"{match.group(1)}<em>{match.group(2)}</em>{match.group(3)}"
    return line
```

Here's what I did:

1. I broke down the `parse` function into smaller functions each doing a specific task. This makes the code easier to read and maintain.
2. I created a function `parse_header` to handle header parsing. This function uses a single regex to match all header levels.
3. I created a function `parse_list_item` to handle list item parsing. This function also handles the opening and closing of the unordered list tags.
4. I created a function `parse_paragraph` to handle paragraph parsing.
5. I created functions `parse_bold` and `parse_italic` to handle bold and italic parsing respectively.
6. I removed the repeated code blocks and replaced them with function calls.
7. I used f-strings for string formatting which makes the code cleaner and easier to read.
---
